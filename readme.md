# 핵심 문제해결 전략

1. 뿌리기 기능 구현

- 토큰 키 발급

해결 : 고유키라고 판단되는 사용자 아이디와 System.currentMiliseconds()를 조합하고, sha2로 암호화 하여 처리
이 때, 암호화 한 값이 128자리가 되고 이 128자리 중에서 랜덤으로 3개의 값만 가져와서 조합하여 토큰 발급
* 중복 발생이 충분히 가능하여, Retry 정책을 10번까지 넣음.

또한, select 한 후에 토큰이 겹치지 않는다고 판단되었으나, 업데이트 하는 과정 중간에 동일 토큰이 발급될 가능성이 존재함.
따라서, LockMode.PESSIMISTIC_READ 옵션을 추가하여 DB Lock을 걸어서 중복의 위험을 낮춤.
(이 부분은 사전 과제의 한계점으로 보임. 실제 서비스에서는 중간에 Redis를 둔다면, 중복 or 동시에 들어오는 데이터의 처리가 가능)

----------------------------------------------------------------------------------------------------------------------------------

2. 받기 기능 구현

해결 : 
- 받기 기능 또한 동시성에 대한 요구사항이 있어, DB Lock으로 처리함.
- 받기 기능 시에 update 쿼리를 발생시키는 데, Write 시에 Lock을 작동하도록 함.
- 마지막으로 사용자에게 응답을 주기 전에 한번 더 검증 쿼리를 발생하여, 고객에게 정확한 데이터를 내려주도록 함.

(이 또한 중간에 Redis나 받기 대기열(SQS)가 존재한다면, 훨씬 편리하게 해결이 가능)

----------------------------------------------------------------------------------------------------------------------------------

3. 조회 기능 구현

- 페이징 처리
- 카페인 1차 캐시 적용
- pageable 적용

해결 : 리스트는 뿌리기나 받기 기능에 비해 사용 빈도가 적고, order by를 하는 기준이 명확함.
또한, 대게 조회 API를 이용한 화면은 페이징 단위로 이동되고 데이터의 큰 변화가 빈번하게 발생하지 않음.
따라서, 페이징 사이즈와 페이징 넘버를 캐시명에 같이 넣어주어서, 동일 페이지 로드할 경우 캐싱처리
Spring Data Jpa에서 제공하는 Pageable 이용하여 처리
----------------------------------------------------------------------------------------------------------------------------------

결론 : 서버가 N대 이상이 되었을 때 동시성에 대한 처리가 관건.
현재 과제에서는 큐 서버나 레디스 서버를 별도로 두지 않는 한 한계가 있음.
따라서 DB Lock을 사용.
속도 측면에서는 문제가 있지만, 과제를 해결하기 위해 DB Lock 처리

----------------------------------------------------------------------------------------------------------------------------------
참고

실패 응답 처리

{
    "errorCode": "0001",
    "errorMessage": "사용자 식별자 및 대화방의 식별자 정보가 존재하지 않습니다."
}
----------------------------------------------------------------------------------------------------------------------------------